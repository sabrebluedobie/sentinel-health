// @ts-nocheck
export const config={runtime:"nodejs"};import{streamText}from"ai";async function handleHeadacheTypes(e,t){try{const r=await readJson(e),o=`\nReturn ONLY valid JSON: an array of 4â€“6 items.\nEach item: { "type": string, "keySymptoms": string[], "likelihood": number 0..1 }.\nSum of likelihoods should be ~1. This is educational, not diagnostic.\nPatient symptoms: ${r?.symptoms||""||"none provided"}\n`.trim(),{textStream:n}=await streamText({model:"openai/gpt-5",prompt:o});let a="";for await(const e of n)a+=e;const s=normalize(safeParseArray(a));t.setHeader("content-type","application/json"),t.status(200).send(JSON.stringify({items:s}))}catch(e){t.setHeader("content-type","application/json"),t.status(500).send(JSON.stringify({error:e?.message||"Server error"}))}}export default async function handler(e,t){const r=new URL(e.url,`http://${e.headers.host}`).pathname.replace(/^\/api\/?/,"");if("headache-types"===r)return handleHeadacheTypes(e,t);t.setHeader("content-type","application/json"),t.status(404).send(JSON.stringify({error:`No route for /api/${r}`}))}async function readJson(e){try{const t=[];for await(const r of e)t.push(r);const r=Buffer.concat(t).toString("utf8")||"{}";return JSON.parse(r)}catch{return{}}}function safeParseArray(e){try{const t=JSON.parse(e);return Array.isArray(t)?t:[]}catch{return[]}}function normalize(e){const t=(e||[]).filter((e=>e&&"string"==typeof e.type&&Array.isArray(e.keySymptoms)&&"number"==typeof e.likelihood)).map((e=>({type:e.type,keySymptoms:e.keySymptoms.slice(0,4).map(String),likelihood:clamp01(Number(e.likelihood))}))),r=t.reduce(((e,t)=>e+t.likelihood),0)||1;return t.map((e=>({...e,likelihood:e.likelihood/r})))}const clamp01=e=>e<0?0:e>1?1:e;